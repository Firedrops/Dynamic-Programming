# A function that checks whether or not a specific output
# can be generated by exact summation of a specific set of inputs
# Inputs can be "re-used" indefinitely. Only non-negative inputs allowed.

# Outstanding problems:
# 1. Only 1 combination is reported per input, rather than all possible.

# Examples
# howSum(7, [5, 3, 4, 7]) returns [3, 4], or [7].
# howSum(8, [2, 3, 5]) returns [2, 2, 2, 2] or [3, 5].
# howSum(7, [2, 4]) returns null. Even inputs cannot result in odd sum.

# Naive/brute-force implementation
# O(n^m * m) time
# O(m) space

# def howSumNaive(targetSum, inputs):
#     if targetSum == 0:
#         return []
#     elif targetSum < 0:
#         return None
#
#     for num in inputs:
#         remainder = targetSum - num
#         remainderResult = howSumNaive(remainder, inputs)
#         if remainderResult is not None:
#             return [*remainderResult, num] # "Spread Operator", equivalent JS is [...remainderResult, num]
#
#     return None
#
#
# if __name__ == '__main__':
#     print(howSumNaive(7, [2, 3, 4]))
#     print(howSumNaive(7, [2, 4]))

# Memoized
# O(n * m^2) time
# O(m) space

def howSumMemo(targetSum, inputs, memo={}):
    if targetSum in memo:
        return memo[targetSum]

    if targetSum == 0:
        return []
    elif targetSum < 0:
        return None

    for num in inputs:
        remainder = targetSum - num
        remainderResult = howSumMemo(remainder, inputs, memo)
        if remainderResult is not None:
            memo[targetSum] = [*remainderResult, num]
            return memo[targetSum]

    memo[targetSum] = None
    return None


if __name__ == '__main__':
    print(howSumMemo(7, [2, 3, 4]))
    print(howSumMemo(7, [6, 5]))    # this is somehow returning [3,2,2] rather than "None"???
    print(howSumMemo(8, [6, 5]))    # this is somehow returning [3,5] rather than "None"???
    # Apparently inputs are being recycled???
    print(howSumMemo(300, [7, 14]))
