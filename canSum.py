# A function that checks whether or not a specific output
# can be generated by summing from a specific set of inputs.
# Inputs can be "re-used" indefinitely. Only non-negative inputs allowed.

# Examples
# canSum(7, [5, 3, 4, 7]) returns TRUE. By 3+4, or 7 by itself.
# canSum(7, [2, 4]) returns FALSE. Even inputs cannot result in odd sum.

# Naive/brute-force implementation
# O(n^m) time
# O(m) space

# def canSumNaive(targetSum, inputs):
#     if targetSum == 0:
#         return True
#     elif targetSum < 0:
#         return False
#
#     for num in inputs:
#         remainder = targetSum - num
#         if canSumNaive(remainder, inputs) is True:
#             return True
#
#
# if __name__ == '__main__':
#     print(canSumNaive(7, [2, 3, 4]))

# Memoized
# O(n * m) time
# O(m) space

def canSumMemo(targetSum, inputs, memo={}):
    if targetSum in memo:
        return memo[targetSum]

    if targetSum == 0:
        return True
    elif targetSum < 0:
        return False

    for num in inputs:
        remainder = targetSum - num
        if canSumMemo(remainder, inputs, memo) is True:
            memo[targetSum] = True
            return True

    memo[targetSum] = False
    return False


if __name__ == '__main__':
    print(canSumMemo(300, [7, 14]))
